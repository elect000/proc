NAME: 江畑 拓哉 ID:201611350
# Problem 1:
始めにチェックする数字の数を受け取り、この数を元にして Vector に要素を保存します。
保存が終わったら check関数 を呼び出して、一つ前の数字との差が条件を満たしているかや数字の重複がないかを調べます。
一つでも違うものがあれば "Not jolly" を出力し、すべての場合で条件を満たしていれば "Jolly" を出力し check関数を終了します。

# Problem 2:
２つの配列を用意し、１つの配列には char型 のキーワードを、もう一つの配列は int型の値を保存します。 i 番目のキーワードと i番目の値は対応付けられています。
文字列を一行ずつ getline関数 で読み取り、一文字ずつ check関数 を適用します。
check関数 では、作成した2つの配列を元に与えられた文字が価値のあるものかを判断しています。返り値はその文字の値で、価値がなければ0を返します。
そして check関数 から返ってきた値をすべて足し合わせることで、求める値がわかります。

# Problem 3:
二次元配列を用意します。i 番目の1次元配列には、 i 番目の兵士の隣人 {left, right} が含まれています。
もし i 番目から j 番目(i < j) の兵士がいなくなれば、 配列の i 番目の値は {left, j の right} 配列の j 番目の値は、 {i の left , right} に更新されます。
更新していく最中に 兵士のいない値 (例えば 10 人しかいないのに 11 人目を隣人にするような場合)を使うことがあれば、それは隣人を見つけることが出来なかったことを示します。その場合の出力には、数字の代わりに '*' を出力します。

# Problem 4:
5 X 5 の配列を2つ用意します。一つは更新用の配列、もう一つは現在の状態を保存するための配列です。
まず入力に基づいて初期状態を配列に保存します。保存する領域は 1-3 X 1-3 です。つまり境界の値に値を入れません（正確には初期値として 0 が入っています）。
次に i X j (1 <= i, j <= 3) の値について上下左右に含まれている値をすべて加算して、 2 で割った余りを更新用の配列に保存します。すべての計算が終わったら、更新用の配列を現在の状態に適用します。これを繰り返し、現在の状態がすべて 0 で埋められたならばその時の繰り返しの回数から 1 を引いた値を返します。

# Problem 5:
チーム数、入力から得られる対戦の情報を保存するための2次元配列(int型)、一次元配列(string型)を準備します。
入力をすべて入力された順番で保存します。
次にチーム数に応じたサイズのベクトルを用意します。ベクトルの i 番目 には i が含まれています。
そしてこのベクトルをソートします。ソートの基準には、先ほど作成した 2 次元配列から得られる値を使います。（実装ではコードを見やすくするためにチームの合計点数を保存する配列を作成していますが、これがなくとも実装は出来ます）
ソートしたベクトルを元に順位付けてチームを出力します。


# Problem 6:
入力をすべてベクトルに保存します。この際に最小数と最大数を記録し、この2つを足し合わせて求める文字列の長さを求めます。
ベクトルにある要素すべてを取り出して、任意の2つを組み合わせます。(同じ要素を組み合わせることはしない)組み合わせた文字列が初めて見るものであれば、初期値 0 と共に map に保存します。そうでなければ 文字列に対応した数字（初期値として 0 が与えられていたもの）をインクリメントします。
最後に map の中で最大の数字を持っている(つまり最も同じ文字列を観測した)文字列を出力します。

# Problem 7:
まず Jack が持っているCDのタイトルをすべて配列に保存します。
次に Jill が持っているCDのタイトルが昇順に入力されるので、それが配列内の一致する部分まで配列の先頭から調べていきます。見つかれば見つかった配列の添字 pos　を記録しておきます。昇順に入力されることが保証されているため、pos 番目以前の配列の要素を調べる必要がないためです。これによって検索を高速化することが出来ます。
配列を最後まで見切ると、それまでにいくつ同じCDのタイトルと見つけたかを出力します。
また始めに入力される Jill の持っているCDの数のタイトルをすべて見切った場合も、同じように値を出力します。

# Problem 8:
配列を一つ用意します。配列のサイズは想定される最大の人数を max_people とするとその倍の数です。
[0 max_people) には友好的な人を意味しています。対して [max_people 2*max_people) には有効的でない人を意味しています。i 番目の初期値として i が保存されています。　
ここ以下で用いる'値'とは '元の値 % max_people' を示します。
入力で i と j の友人関係が定義されると、配列の i 番目の値 i' と j番目の値 j' の値を調べ、小さい方の値を大きい方の値で更新します。配列の i + max_people 番目の値　と　j + max_people 番目の値も同様に処理します。
入力で i と j の敵対関係が定義されると、配列の i 番目の値 i' と j + max_people 番目の値 j' の値を調べ、小さい方の値を大きい方の値で更新します。同様に i + max_people 番目の値 と j 番目の値も同様に処理します。
入力で i と j が友好関係であるかを調べることが指示されると、配列の i 番目/ j 番目の値を調べます。配列の i 番目の値 i' が i であるかを調べ、 i であれば i を検査に用います。 i でなければ、i' について再帰的にこれを繰り返し、最終的に i* を得ます。同様に j* を得て、i*、 j* が等しいかを調べます。等しければ i と j は友人です。
入力で i と j が敵対関係であるかを調べることが指示されると、i と j + max_people について友好関係であるかを調べます。友好的な i と 友好的でない j が友好的なので、つまり i と j は敵対関係にあります。
