NAME: 江畑 拓哉 ID:201611350
# Problem 1:
まず考えなければならない点として、すべてのケースにおいて想定される最大の資金が200以下であるということが挙げられます。つまり、資金Mは絶対に200を超えず、また0以上であることが保証されるということです。つまり、配列サイズ 200 (今回は計算の都合などもあり 201 とした) 配列 A があればそのすべての必要経費のパターンを網羅できることになります。
そしてもう一つ考えなければならない点として、買うものは最大で20個であるということ、そしてすべての品物を揃えなければならないということです。つまりすべての品物を買った状態と、それ以外の状態は区別されるべきということです。今回はそれを表現するために、配列 A を20個用意することで解決しました。
アルゴリズムの流れとしては、i 番目の品物についての数列を受け取ると、 i - 1 番目の 配列 A に true として保管されている 途中資金 v (例えば 2品買ったところで 10 20 70 が想定されていた時、A[10] = true, A[20] = true A[70] = true となっている)にその品物の値段を足した金額 v を用いて、、i 番目の配列 A' の A[v + v'] に true を与えます。
このアルゴリズムがすべての品物について検討を終えた時、20番目の配列 A'' は取りうる資金のリストと同義になります。最後に、問題で聞かれる最大資金 M から 0 へ向かって順に A'' の値を見ていき、最初に見つかった値がこの問題で尋ねられている答えになります。そしてもし 0 まで見て何も答えが見つからなければ、 ``no solution'' を返します。
# Problem 2:
スタート地点として初期値 -1 をセットしておきます。入力された数列を順番に加算しつつ見ていきます。i番目までの和 sum が0未満になった場合、i にスタート地点を更新します。同時に加算もリセットし、再び0から加算を繰り返していきます(sum = 0 とする)。そうでない場合、もしi番目までこの計算をして得られた和がそれまでの最大値を更新した場合や、i - start の値がそれまでの最大値における max_end - max_start の値よりも大きければ max_end を i、 max_start を start に、max を sum に更新します。
最後に求まっている max_start max_end が求めたい値です(実装上では計算の都合上ずらしている部分を最後に加算しています)。また max が 0 以下であった場合には要件通り "Route n has no nice parts"を出力します。
# Problem 3:
注意しなければならない点として、与えられる図形は30*30未満の正方行列として表すことが出来るということが挙げられます。
まず入力される行列をすべて配列 matrix に入れます。次に matrix から一行取り出して、仮に "0011100011" であったとすれば、これを "0012300012" と変換します。つまり自身が 1 で左側が 1 以上ならば 左側の値+1 に自身の値を更新します。
次に、配列全体を見ます。仮に以下のようになっていたと（解説の簡略化のため正方行列ではありません）します。
"0012300012"
"0001200000"
"0001200000"
"0000100000"
"0000000000"
まず[0,0]要素から右に眺めていきます。すると[0,2]が 1 であることがわかります。但しその次が 2 です。この場合はそのまま進んでいきます。これから更に進んでいき、[0,4]が 3 そしてその次が 0 になっていることがわかります。すると少なくとも四角形の最大値として 3 * 1 = 3 を考えることが出来ます。この値をv という配列(実装上はvector)に保存しておきます。次に下へ進んでいきます。[1, 4] は 2 です。3 > 2 なので 2 を残します。現時点でわかっていることは、2 * 2 = 4 の四角形の面積を考えることが出来ているということです。この値も同様に v に入れておきます。以下同様にしていくと、[4,4] が 0 となっていることに気が付きます。これ以上四角形を考えることは出来ないので、計算を打ち切ります。
再び[0,3]から右に眺めていきます。一行目を見終わったら、二行目の左端から同様に処理します。
すべての配列の要素について検証が終わったら v をソートして最大値を求めます。それが求めたい最大値になります。
