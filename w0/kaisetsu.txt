# Problem 1:
入力がなくなるまで２つずつデータを読み込み、その２つのデータに対して関数checkを適用しました。
check 関数は、第一引数に小さい値、第二引数に大きい値を受取り、２つの数の間にあるloop関数を呼び出し返り値の最大値を返します。
loop 関数は、問題文にあるアルゴリズムを実行し求める数を求めます。

# Problem 2:
３つの数字に対して順番を計算するcheck関数を作ることで課題を解きました。
if 文を組み合わせることで 3! = 6 通りの順位に関する組み合わせを探索しています。

# Problem 3:
与えられた条件を満たすホテルを見つけて、そのコストを毎処理ごとに今までの最低コストと比較し更新しました。

# Problem 4:
入力された行を std:istringstream に保存し、そこから一つづつデータを取り出しました。取り出したデータを比較し、より大きい方を残すことで最大値が求まり、それを出力しました。

# Problem 5:
日付に関するクラス Date を作成しました。このクラスの関数として、うるう年を判定する関数 check_leap を作り、更に日付の足し算に関してオペレータを上書きすることで main 関数を簡潔にしました。

# Problem 6:
カードと数字の対応付けをする関数 printout を作成し、出力に関する問題を解決しました。カードのシャッフルは配列 shuffle に保存し、これを元に change 関数でカードの順番を更新しています。
change 関数は、配列の j 番目にあるカードを、配列 shuffle に指定された i 番目の位置に格納しています。

# Problem 7:
5時間分の時間を経過させ、条件に合う値を調べました。条件は check 関数で調べており、 ``2 * n * 周期'' (青信号になり始めてから、次に青信号になり始める時間) を元にして調べていますが、この n の値を毎回保存しているため、 n を 0 から計算する手間を省きました。

# Problem 8:
22マスの面を作り、端はすべて0で埋めたことで、周囲の人間を数える計算を共通化出来るようにしました。また、周囲の人間は決して10人を超えないことから、今の状態を一桁目、次の状態を二桁目に保存することで配列の数を減らしました。(例：今の状態で人がおらず、次の状態で人がいる場合=>10)
