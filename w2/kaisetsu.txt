NAME: 江畑 拓哉 ID:201611350
# Problem 1:
始めに入力される頭と騎士の情報を配列に保存しておきます。
次に2つの配列をソートします。そしてチェック関数を呼び出して、一つずつ頭を切り倒して行きます。
倒し方は、残存する一番小さい頭に対して、一番弱い騎士を割り当てる方法です。
もしその騎士で倒せなければ、次に大きな騎士をその頭にあてがいます。
このとき注意する点として、（2つの配列がソートされているため）飛ばした騎士は他の生き残っている頭を倒すことが出来ないという点です。
このため、頭の個数をM,騎士の数をNとすると、 O(M+N)で計算できるアルゴリズムであると言えるでしょう。

# Problem2:
以下の2つのアスキーアートをご覧ください。
1つめは、”1/1”から"LRRL"を通して"5/7"に遷移していく様子を示しています。
2つめのアスキーアートでは、"2/3"、"5/7"という数字を分解していくアルゴリズムを示しています。
"2/3 = 1/(3/2)"という部分からわかるように、（分母>分子）であるとき、反転させることで分子を1にしているということがわかります。
また"3/2=1+(1/2)"という部分からは、(分子>分母)であるならば、整数と少数に分解するとしていることがわかります。"5/2"から"2+(1/2)"と分解して、”RR”と”R”を二回繰り返していることがわかります。
そして分母と分子が入れ替わるたびに"L"と"R"が入れ替わっていることがわかります。
最後に終了条件が "1/n" の形になっていることがわかります。
以上のことから、分数が入力されればこのアルゴリズムを用いることで適切な"L"と”R”を用いた文字列を求めることが出来ます。

// 1/1 => 1/2 => 2/3 => 3/4 => 5/7
//     L      R      R      L

//  2      2     1        1
// --- =  --- = --- = -------
//  3      3     3     1 + 1 <! L
//              ---       ---
//               2         2 <! R
//
//  5      5     1      1
// --- =  --- = ---- = ------    
//  7      7     7     1 + 2 <! L
//              ---       ---
//               5         5


//  2      1
// --- = ------
//  5     2 + 1 <! RR
//           ---
//            2 <! L

# Problem3:
i行j列にチェスのコマを置きますが、同じ行に2つコマが置かれることがないため一行ずつ検索していきます。
また j は10未満の値を取ることから、配列を使わずにintの値 state でコマの状態を表現することが出来ます。
入力されたチェスの位置については、{strict_x, strict_y}という値で保存しておきます。
またいくつ目のコマについて検討しているかを示すために stage という変数を用いています。
(a-1)行目以前のすべてが 8 Queen の条件を満たしているとして、a 行目以降のコマの位置については、以下のようにして決定します。
すべての可能性 {a, b} (1 <= b <= 8)について、条件を満たしているか check 関数で判定します。もし条件を満たしていれば、その位置を仮決定して (a + 1) 行目のコマについて同様の議論を行います。条件を満たしていなければ、その位置は見なかったことにします。
上のアルゴリズムを実行し stage 変数からすべてのコマを置き終わったとわかった時、その時のチェスの状態を表示します。問題では小さい順に表示せよ、と書かれていますが、可能性を検討している部分で小さい順に見ていることから、特に手を加えずとも小さい順に出力することが可能になります。
